Compito: dato il testo/abstract di un paper scientifico, genera un oggetto JSON (in inglese) che lo descriva seguendo esattamente struttura, tipi e vincoli sotto. Non inventare informazioni: se un’informazione non è presente, usa stringa vuota, array vuoto o boolean coerente. Restituisci esclusivamente JSON valido (niente testo, niente markdown, niente backticks, niente virgole finali). - Struttura e tipi (solo questi campi; ordine libero, chiavi esatte): - id: stringa, obbligatorio. Slug minuscolo “cognomeYYYYprima-parola-del-titolo” (es. “hignette2009fuzzy”). - added: vuoto. - year: intero, obbligatorio. Anno di pubblicazione. - firstAuthor: stringa, obbligatorio. Solo cognome del primo autore (es. “Hignette”). - authors: array di stringhe, obbligatorio. Nomi completi (nome + cognome) in ordine di firma, obbligatorio. - title: stringa, obbligatoria. - venue: oggetto, obbligatorio. - type: enum “conference” | “journal”. - acronym: stringa. Acronimo della venue (senza anno). - nameOfApproach: stringa. Nome proprio del metodo/sistema (se presente). - techniqueTags: array di stringhe. Tag controllati per facilitare il faceting; valori ammessi: “rule-based”, “SVM”, “CRF”, “clustering”, “embeddings”, “ontology-driven”, “transformer”. - coreTasks: oggetto, obbligatorio. Solo: - cta, cpa, cea, cnea: boolean. True se il paper copre esplicitamente quel task, altrimenti false. - supportTasks: oggetto, obbligatorio (può contenere stringhe vuote). Solo: - dataPreparation: oggetto con description, spellChecker, unitsOfMeasurements (tutte stringhe). - columnClassification, subjectDetection, datatypeAnnotation, typeAnnotation, predicateAnnotation, nilAnnotation: stringa. - entityLinking: oggetto con description, candidateGeneration, entityDisambiguation (tutte stringhe). - mainMethod: oggetto, obbligatorio. - type: enum “Hybrid” | “Supervised” | “Unsupervised”. - technique: stringa, obbligatoria. Algoritmi/strategie (es. “SVM”, “rule-based”, “clustering”). - supervision: oggetto, opzionale; includere solo se mainMethod.type = “Supervised”. - type: enum “supervised” | “weakly-supervised” | “distant” | “semi-supervised” | “unsupervised”. - labelsSource: stringa (origine etichette: crowd, silver, heuristics, distant KB, etc.). - revision: oggetto, obbligatorio. - type: enum “Fully automated” | “Semi automated” | “None”. - description: stringa. - domain: oggetto, obbligatorio. - domain: enum “Dependent” | “Independent”. - type: stringa. Se “Dependent”, specifica il dominio (es. “biomedical”); se “Independent” può essere vuota o generica. - validation: oggetto, obbligatorio. - goldStandard: stringa (nome/descrizione del gold standard, se applicabile). - metrics: array di stringhe. Valori ammessi includono: “Precision”, “Recall”, “F1”, “F0.5”, “F2”, “Accuracy”, “Top-1 Accuracy”, “Top-k Accuracy”, “Micro-Precision”, “Macro-Precision”, “Micro-Recall”, “Macro-Recall”, “Micro-F1”, “Macro-F1”, “Weighted-F1”, “MAP”, “MRR”, “NDCG”, “P@k”, “R@k”, “F1@k”, “Hits@k” (es. “Hits@1”, “Hits@5”, “Hits@10”), “MRR@k”, “MAP@k”, “NDCG@k”, “ROC-AUC” (o “AUC-ROC”), “PR-AUC” (o “AUPRC”), “AP” (Average Precision), “EM” (Exact Match), “ARI”, “NMI”, “Purity”, “Silhouette”. - code: stringa. URL al codice (repo, zip, pagina progetto) oppure stringa vuota se non disponibile. - license: stringa, obbligatorio. Nome licenza o “Not specified” se non dichiarata. - inputs: oggetto, obbligatorio. - typeOfTable: stringa, obbligatoria. Origine/formato tabelle (es. “HTML tables”, “Web tables”, “CSV”, “PDF”). - tableSources: array di stringhe; enum: “web” | “pdf” | “spreadsheet” | “relational” | “scientific” | “wiki” | “gov-open-data”. - kg: oggetto, obbligatorio. - tripleStore: stringa, obbligatoria. KB/KG usati (es. “DBpedia”, “Wikitology”). - index: stringa. Eventuale indice sul KG. - output: stringa, obbligatorio. Formato/artefatto (es. “RDF”, “JSON-LD”, “CSV”, “XML”). - applicationPurpose: stringa. Scopo/applicazione del sistema. - userInterfaceTool: stringa. UI/strumento (es. “CLI”, “Web UI”, nome tool). - usesLLM: oggetto, opzionale. - modelName: stringa (es. “GPT-4o”, “Llama-3-70B”). - prompting: enum “zero-shot” | “few-shot” | “CoT”. - checkedByAuthor: vuoto. - checkedByAi: true. - doi: stringa, obbligatorio. URL canonico “https://doi.org/...”. - citations: array di oggetti, obbligatorio. Ogni elemento: - ref: stringa, slug breve “cognomeYYYYprima-parola-del-titolo” (se non deducibile, lascia vuoto). - title: stringa, titolo della citazione. - Vincoli e coerenza: - Nessun campo oltre a quelli elencati (additionalProperties: false). - Enum stretti: mainMethod.type ∈ {Hybrid, Supervised, Unsupervised}; revision.type ∈ {Fully automated, Semi automated, None}; domain.domain ∈ {Dependent, Independent}. - Se domain.domain = “Dependent”, domain.type deve essere valorizzato con un dominio specifico; se “Independent”, domain.type può essere vuoto o generico. - Se DOI è presente e title.link è vuoto, imposta title.link alla URL canonica del DOI. - techniqueTags deve usare solo i valori ammessi; scegli più tag ove pertinente. - mainMethod.supervision va incluso solo se mainMethod.type = “Supervised”; in caso contrario omettere l’intero oggetto. - inputs.tableSources deve usare solo i valori dell’enum; usare array vuoto se non specificato. - usesLLM, se presente, deve avere prompting ∈ {zero-shot, few-shot, CoT}. - validation.metrics deve usare i valori ammessi sopra; sono consentite varianti con suffisso “@k” (es. “MRR@10”, “NDCG@20”) e prefissi “Macro-”, “Micro-”, “Weighted-”. Se incerto, usare array vuoto. - Convenzioni di naming metriche: nomi in MAIUSCOLO, includere “@k” per cutoff, mantenere i prefissi Macro-/Micro-/Weighted- come parte del nome (es. “Macro-F1”, “MRR@10”). - Popola supportTasks in modo coerente con i coreTasks: - typeAnnotation solo se cta = true. - predicateAnnotation solo se cpa = true. - entityLinking solo se cea = true (altrimenti lascia oggetto con campi stringa vuoti). - nilAnnotation solo se cnea = true. - authors deve includere firstAuthor come primo elemento ed essere coerente con l’ordine di firma. - Regole di estrazione: - Sii conservativo: deduci un campo solo se supportato dal testo; altrimenti lascia vuoto/false. - mainMethod.type usa esclusivamente forme canoniche: “Supervised”, “Unsupervised” o “Hybrid”. - technique deve essere coerente con type (es. supervised → “SVM”, “CRF”; unsupervised → “clustering”, “embedding-based”; rule-based → specifica regole/ontologie). - Riassumi description/testo di supportTasks.*, revision.description e validation in massimo 1–2 frasi ciascuno. - Normalizzazione: - id: minuscolo, senza spazi, accenti rimossi. - Pulizia spazi doppi, rimozione suffissi/anno dal conferenceJournal. - Niente valori null o “N/A”: usa stringa vuota/[]/false dove appropriato. - Regole di output: - Restituisci un singolo oggetto JSON valido, senza testo aggiuntivo. - Non usare blocchi di codice né backticks. - Chiavi sempre tra doppi apici, nessun commento, nessuna virgola finale. - Per campi sconosciuti: stringa vuota; array vuoto; boolean false. Input: caricherò il paper. PROCEDURA: 1. Prima analizza il testo e mostra il tuo ragionamento step-by-step 2. Poi genera l'oggetto JSON finale conforme ai vincoli sopra Il ragionamento deve essere chiaro e strutturato, mostrando come arrivi alle conclusioni per ogni campo importante.